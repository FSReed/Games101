# 作业3简记

## 代码原理梳理

本次作业通过`OBJ_Loader`加载模型，加载结果是一堆`Triangle`的集合，并且每个`Triangle`的顶点法向量已经被计算好。重点在于`draw`函数中对于每个三角形的处理：  
首先对三角形进行**view + model变换（注意没有投影变换，只是把三角形从局部坐标转换到了世界坐标）**，提取三角形的`(x, y, z)`坐标作为世界坐标记录为`viewspace_pos`；  
然后对三角形的法线坐标进行`view * model`的**逆变换**，这看似和坐标变换矛盾，实际是保证变换后的法向量与变换后的平面依旧垂直的必然要求。记对于坐标进行变换的矩阵为 $M$ ,对于法向量 $n$ 进行变换的矩阵为 $M'$:

$$
M \times (x, y, z)^T = (x', y', z')^T \\
M' \times (n_x, n_y, n_z)^T = (n_x', n_y', n_z')^T \\
$$

变换后法向量垂直于变换后平面：

$$
(n_x', n_y', n_z') \times (x', y', z')^T = 0 \\
$$

代入原式并展开：

$$
(n_x, n_y, n_z) \times (M')^T \times M \times (x, y, z)^T = 0
$$

由于原法向量和原平面是垂直的，这就要求 $(M')^T \times M = I$ ,这也就说明 $M' = (M^{-1})^T$ ,对应于代码框架中的 `(view * model).inverse().transpose()`  
三角形的 $(x, y, z)$ 值都通过齐次坐标除法转换为了经过MVP投影后的空间点坐标，z表达的就是深度值。而`viewspace_pos`中的坐标就是三角形的顶点世界坐标，没有经过投影变换，也就无法表征深度，只用于插值计算像素点的空间坐标，用于后续shader着色  
对于屏幕上投影出的三角形内一个点 $(x, y)$ ，该如何插值计算该点属性？其实这需要用到透视投影矫正，设该点的插值深度为 $w_0$ ，利用三角形三个顶点的深度 $w_i$ 可以进行这样的插值：

$$
\frac{1}{w_0} = \sum_{i = 0}^3{\frac{1}{w_i}}
$$

对于节点属性插值可以通过类似方法计算，这里的 $attr$ 可以表示颜色、法向量、贴图坐标、世界坐标等各种属性。注意代码框架中向`rasterize_triangle`中传入了`viewsapce_pos`，这就是用来插值像素点的空间坐标的

$$
\frac{attr}{w_0} = \sum_{i = 0}^3{\frac{attr_i}{w_i}}
$$

## fragment_shader 绘制过程分析

首先还是要获取三角形的 bounding-box，之后判断一个像素点 $(x, y)$ 是否在三角形内，如果不在则不绘制；在插值获得深度之后，可以利用 z-buffer 判断深度，确定是否需要继续绘制当前像素；如果当前深度最小，更新 z-buffer，构建 fragment_shader 需要的 payload，将其传入对应的 shader 中进行着色，利用 shader 的返回结果绘制当前像素（而非直接用插值得到的 color 绘制）
